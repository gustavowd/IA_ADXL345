/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 09.10.2023 15:56:24

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1520;
#else
constexpr int kTensorArenaSize = 496;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[4];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,21 } };
const ALIGN(16) float tensor_data1[10] = { -0.027082234621047974, 0, 0, -0.032080505043268204, -0.035322479903697968, 0, -0.047104526311159134, 0.044836942106485367, -0.014867826364934444, -0.018559686839580536, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { 0.014701944775879383, -0.006169675849378109, 0, 0, 0.02458176389336586, -0.024562438949942589, -0.0026799747720360756, -0.036079492419958115, 0.08891112357378006, -0.036702122539281845, -0.01797759160399437, -0.015836160629987717, 0.04279545322060585, -0.03363458439707756, -0.038213323801755905, 0, 0.040636036545038223, -0.032938811928033829, -0.031310684978961945, 0.0027610454708337784, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(8) float tensor_data3[2] = { -0.044135957956314087, 0.044135961681604385, };
const TfArray<1, int> tensor_dimension3 = { 1, { 2 } };
const ALIGN(16) float tensor_data4[20*21] = { 
  -0.0044344901107251644, -0.10555349290370941, -0.087005212903022766, 0.33443349599838257, 0.13383097946643829, 0.15728588402271271, 0.08100765198469162, -0.26742541790008545, 0.099107883870601654, -0.32636061310768127, -0.038475789129734039, 0.10864628851413727, -0.36031866073608398, -0.27500176429748535, -0.11269925534725189, 0.30219313502311707, 0.059737663716077805, 0.23377136886119843, -0.22486488521099091, -0.2260192334651947, 0.28724166750907898, 
  -0.37045380473136902, 0.0095649585127830505, 0.29839253425598145, 0.04483301192522049, -0.088943533599376678, 0.071842692792415619, 0.12634678184986115, 0.12193834036588669, 0.17266274988651276, 0.35485047101974487, -0.23396427929401398, 0.16608771681785583, 0.059648051857948303, 0.079138346016407013, 0.24217501282691956, -0.19130755960941315, 0.30602070689201355, 0.19812393188476562, 0.39604583382606506, -0.21195860207080841, -0.047978397458791733, 
  0.24429163336753845, -0.04985615611076355, -0.32345280051231384, -0.26787090301513672, 0.16321119666099548, -0.19852636754512787, 0.23154780268669128, 0.31713250279426575, 0.3608795702457428, -0.032660454511642456, -0.28493911027908325, 0.06126740574836731, -0.27475512027740479, 0.18259575963020325, -0.22011776268482208, 0.26263174414634705, 0.12274113297462463, 0.22194495797157288, 0.0049406290054321289, 0.16065219044685364, 0.37564685940742493, 
  -0.31306314468383789, 0.19772687554359436, -0.20016488432884216, 0.22388491034507751, -0.031235247850418091, 0.21957346796989441, -0.036931157112121582, 0.36527696251869202, 0.18712523579597473, -0.31938856840133667, 0.30687436461448669, 0.30196729302406311, 0.18291851878166199, 0.23279574513435364, 0.1618560254573822, -0.084348857402801514, -0.28828135132789612, -0.1831333339214325, 0.12533482909202576, 0.23790177702903748, -0.24719329178333282, 
  0.38266873359680176, 0.090038962662220001, 0.0731629878282547, -0.23843647539615631, -0.34062129259109497, -0.29793080687522888, 0.30220922827720642, -0.10633657872676849, -0.19285702705383301, 0.20540039241313934, -0.12455576658248901, 0.05237719789147377, -0.25189831852912903, -0.17768436670303345, -0.27039322257041931, 0.18734213709831238, 0.20747572183609009, 0.24185454845428467, -0.037435617297887802, -0.091198161244392395, -0.043508086353540421, 
  -0.1777719110250473, 0.22496269643306732, 0.056159906089305878, -0.029661683365702629, -0.12227759510278702, -0.29604297876358032, 0.039705481380224228, 0.38119274377822876, -0.14277736842632294, 0.087805047631263733, -0.3501301109790802, -0.13310478627681732, -0.37197428941726685, 0.17226555943489075, 0.061320174485445023, -0.0083387084305286407, -0.35099771618843079, 0.089748553931713104, -0.1400376558303833, -0.0062718628905713558, -0.33627471327781677, 
  0.18397854268550873, -0.1038980707526207, -0.13776354491710663, -0.20847760140895844, -0.23263795673847198, -0.36736708879470825, -0.12127567827701569, 0.27201899886131287, -0.13021685183048248, 0.034499794244766235, -0.011857394129037857, -0.025507407262921333, 0.0066590448841452599, 0.22323551774024963, 0.15206709504127502, -0.057026319205760956, -0.14975309371948242, -0.18951307237148285, 0.37417399883270264, 0.29604673385620117, -0.17639194428920746, 
  0.23290044069290161, -0.43236908316612244, 0.11586682498455048, 0.28322198987007141, 0.28921866416931152, 0.13692326843738556, 0.13165833055973053, 0.18206222355365753, -0.092487931251525879, 0.3451370894908905, -0.053605023771524429, 0.39041662216186523, -0.10744236409664154, 0.17433036863803864, -0.22183620929718018, -0.33997774124145508, -0.10397753864526749, -0.18472863733768463, -0.24406144022941589, 0.3357870876789093, 0.26419636607170105, 
  0.33481922745704651, 0.3997383713722229, 0.2477848082780838, 0.030200911685824394, -0.27955237030982971, 0.16401876509189606, -0.11450526118278503, -0.29545140266418457, -0.10168585926294327, -0.13084211945533752, -0.043970994651317596, 0.16075506806373596, 0.15130162239074707, -0.20851331949234009, -0.0016221298137679696, -0.22962279617786407, 0.09308614581823349, -0.23384454846382141, 0.32263341546058655, 0.034241646528244019, 0.30428984761238098, 
  -0.37595683336257935, 0.11365916579961777, -0.32423648238182068, -0.059292856603860855, -0.25084483623504639, 0.24537329375743866, -0.32590886950492859, 0.01810346357524395, -0.18802216649055481, -0.36114749312400818, -0.30520966649055481, -0.24254801869392395, -0.36346384882926941, -0.085126437246799469, -0.22958125174045563, 0.31099098920822144, -0.034451667219400406, 0.21994839608669281, 0.25787872076034546, -0.2734430730342865, -0.11972656100988388, 
  0.31602871417999268, 0.074808329343795776, 0.15863986313343048, -0.35453253984451294, -0.25850659608840942, -0.13941480219364166, 0.23205278813838959, 0.074297256767749786, -0.009904397651553154, 0.13926109671592712, -0.27714803814888, 0.12790080904960632, 0.11350627243518829, -0.28553634881973267, 0.18730150163173676, -0.20759037137031555, 0.0029091767501085997, 0.002819577232003212, 0.13872218132019043, 0.085300728678703308, -0.3183269202709198, 
  -0.069464631378650665, 0.11805984377861023, 0.32239261269569397, -0.13108038902282715, -0.28235828876495361, -0.32417398691177368, 0.39135774970054626, -0.13448567688465118, 0.29348018765449524, -0.072960555553436279, 0.34006118774414062, 0.36306384205818176, 0.25595620274543762, 0.35928058624267578, -0.12702424824237823, 0.18519546091556549, -0.14494732022285461, -0.12089496105909348, 0.35316282510757446, 0.021777834743261337, -0.074028760194778442, 
  -0.10326647013425827, -0.30340731143951416, 0.011422171257436275, -0.079610079526901245, 0.26848936080932617, -0.35046324133872986, -0.24906134605407715, -0.3922649621963501, -0.32998877763748169, 0.15798528492450714, -0.10935115069150925, -0.3720325231552124, 0.073660470545291901, 0.18648409843444824, -0.14575588703155518, 0.26389676332473755, 0.040736641734838486, -0.12629020214080811, 0.32548999786376953, -0.071260042488574982, 0.21870119869709015, 
  0.049883406609296799, -0.43875893950462341, -0.17700706422328949, -0.054483365267515182, 0.30382087826728821, 0.3969530463218689, -0.29067197442054749, 0.38294908404350281, -0.022981178015470505, 0.11881124228239059, 0.10051125288009644, 0.12908947467803955, 0.36401495337486267, 0.12837548553943634, -0.045185334980487823, -0.24147579073905945, -0.35515856742858887, -0.039595678448677063, -0.28900372982025146, -0.14104913175106049, -0.34536436200141907, 
  0.28412672877311707, -0.38695842027664185, -0.18027494847774506, 0.033479932695627213, -0.012970310635864735, -0.2044055163860321, -0.14827181398868561, 0.15143224596977234, 0.20008100569248199, 0.14779229462146759, 0.38598304986953735, -0.35756829380989075, -0.30662131309509277, 0.38138985633850098, -0.35773104429244995, -0.13070684671401978, -0.32741755247116089, 0.049187704920768738, 0.20433872938156128, -0.33590519428253174, 0.26882243156433105, 
  -0.00034302473068237305, 0.32029107213020325, -0.28240048885345459, -0.3570619523525238, -0.35511773824691772, 0.10320669412612915, -0.046462744474411011, 0.061809539794921875, 0.13779595494270325, 0.12555328011512756, -0.023297131061553955, 0.14581820368766785, -0.21194697916507721, 0.17709651589393616, 0.17860123515129089, 0.29394486546516418, 0.062552154064178467, 0.16749438643455505, 0.13280919194221497, 0.22393056750297546, -0.34697264432907104, 
  0.064636707305908203, -0.18445394933223724, -0.14222687482833862, 0.011489193886518478, 0.34357470273971558, -0.11622001230716705, -0.15301312506198883, -0.30045303702354431, 0.11239492893218994, -0.36051690578460693, -0.35588288307189941, -0.1433858722448349, 0.065280281007289886, 0.16542138159275055, -0.15001657605171204, 0.11898290365934372, -0.31243062019348145, -0.19291935861110687, 0.16951972246170044, -0.094385378062725067, -0.27744156122207642, 
  -0.10542102158069611, 0.14553064107894897, 0.3186454176902771, 0.23531840741634369, 0.24449051916599274, -0.087144665420055389, -0.11769375950098038, 0.34692367911338806, 0.16154587268829346, -0.018867816776037216, -0.10384518653154373, 0.39983916282653809, -0.10445304960012436, 0.29934635758399963, -0.24288393557071686, -0.098697416484355927, -0.23702855408191681, 0.12495757639408112, 0.3738684356212616, -0.19443711638450623, 0.1959415078163147, 
  -0.37496843934059143, -0.15403997898101807, 0.19419725239276886, -0.39891001582145691, 0.16112165153026581, 0.046791113913059235, -0.2330145388841629, -0.020808113738894463, 0.0040314123034477234, -0.11797009408473969, -0.33768752217292786, -0.13216294348239899, -0.31267872452735901, -0.26056081056594849, -0.27640438079833984, -0.18933679163455963, 0.026315715163946152, -0.23080550134181976, -0.22073069214820862, 0.11402878910303116, -0.22812855243682861, 
  -0.019695153459906578, 0.19620993733406067, 0.0015714132459834218, -0.20748963952064514, -0.036761056631803513, -0.12738554179668427, 0.11126528680324554, -0.053163643926382065, 0.26904618740081787, 0.25784754753112793, -0.3140842616558075, 0.29690402746200562, 0.26089379191398621, -0.0090494444593787193, -0.014752651564776897, -0.15770457684993744, -0.020613119006156921, -0.32987657189369202, -0.21247030794620514, 0.094040393829345703, -0.15326841175556183, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,21 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.13556762039661407, -0.29567396640777588, -0.2588837742805481, 0.049101203680038452, 0.35747048258781433, 0.13417650759220123, 0.43442118167877197, -0.51767259836196899, -0.081049658358097076, -0.14258341491222382, 0.065760716795921326, 0.071906685829162598, 0.24769876897335052, 0.54562628269195557, 0.2424091249704361, -0.31586644053459167, 0.038155540823936462, -0.24810682237148285, -0.21730752289295197, 0.21019574999809265, 
  -0.21513541042804718, -0.43652644753456116, 0.25989925861358643, 0.25670373439788818, 0.20556908845901489, -0.15646842122077942, -0.19914223253726959, -0.36983609199523926, -0.35554879903793335, 0.069873809814453125, -0.20073221623897552, -0.2023371160030365, 0.2409820556640625, 0.084498703479766846, 0.26755255460739136, 0.3430597186088562, -0.19190970063209534, 0.13136303424835205, -0.1693665087223053, -0.11774033308029175, 
  -0.086540102958679199, -0.36983108520507812, -0.011426568031311035, 0.40303337574005127, -0.18503651022911072, -0.22609998285770416, -0.13627669215202332, 0.078819572925567627, -0.15676471590995789, -0.043710947036743164, 0.12338340282440186, 0.19389015436172485, -0.081969767808914185, -0.33017858862876892, -0.050489902496337891, -0.26666605472564697, 0.32243669033050537, -0.3727266788482666, -0.38322222232818604, -0.30915829539299011, 
  0.20519363880157471, 0.034345898777246475, 0.35992997884750366, 0.013337910175323486, -0.28112828731536865, 0.29806599020957947, -0.22179272770881653, -0.20354191958904266, -0.14984828233718872, 0.2747243344783783, 0.35460436344146729, 0.17046961188316345, -0.28797236084938049, -0.30385217070579529, -0.0076384865678846836, -0.17162406444549561, -0.094553053379058838, -0.24658063054084778, 0.40878552198410034, 0.39237821102142334, 
  -0.20861983299255371, 0.21184384822845459, -0.36935180425643921, -0.16372278332710266, -0.35156932473182678, 0.26797693967819214, -0.13651461899280548, 0.071351885795593262, -0.39511439204216003, 0.22134464979171753, 0.3182988166809082, 0.20407555997371674, -0.10273469984531403, 0.19348005950450897, 0.08214259147644043, -0.36372420191764832, -0.2027779221534729, 0.34962666034698486, 0.26605743169784546, 0.29140561819076538, 
  -0.33576247096061707, 0.26865863800048828, -0.2659904956817627, 0.19467127323150635, -0.11647129058837891, -0.44642287492752075, -0.025772631168365479, 0.29864662885665894, -0.44512087106704712, -0.17979496717453003, 0.29691082239151001, 0.22912448644638062, -0.19458532333374023, 0.23980724811553955, -0.091879725456237793, -0.25903475284576416, -0.14094427227973938, 0.23669981956481934, -0.25955837965011597, 0.015761494636535645, 
  0.29694396257400513, 0.16397352516651154, -0.22562752664089203, -0.30041342973709106, 0.27981606125831604, 0.30386540293693542, 0.043800726532936096, -0.1814405769109726, -0.14274807274341583, -0.002507420489564538, 0.21150268614292145, 0.14140541851520538, -0.30325210094451904, -0.1155579537153244, 0.028693441301584244, -0.06756243109703064, 0.21722406148910522, -0.12383567541837692, -0.067711479961872101, -0.062621265649795532, 
  -0.0068514165468513966, 0.3649754524230957, 0.17830127477645874, 0.23511844873428345, -0.016577834263443947, 0.32994535565376282, 0.33348086476325989, -0.38432183861732483, 0.47891554236412048, -0.097093470394611359, -0.19751980900764465, 0.44625535607337952, 0.29082828760147095, -0.1024453192949295, -0.36381277441978455, 0.19092845916748047, 0.3557666540145874, 0.062212873250246048, 0.069794923067092896, 0.25059258937835693, 
  0.22747910022735596, 0.1431470662355423, 0.20962709188461304, 0.15653890371322632, 0.3195364773273468, 0.11341138184070587, -0.41686040163040161, -0.10319206118583679, -0.12944702804088593, 0.047066181898117065, 0.34870046377182007, 0.068515188992023468, -0.034214608371257782, -0.40212592482566833, -0.1313498318195343, 0.36558049917221069, -0.34911337494850159, 0.2574017345905304, -0.19608744978904724, -0.12500813603401184, 
  0.17203702032566071, -0.29005065560340881, -0.061477065086364746, -0.0076735317707061768, 0.28520676493644714, 0.36813434958457947, -0.076080828905105591, 0.046768713742494583, 0.2743593156337738, -0.35574465990066528, -0.25008028745651245, 0.17193353176116943, -0.30161857604980469, -0.20926780998706818, 0.21919333934783936, -0.071695268154144287, -0.080309517681598663, 0.32199826836585999, -0.0055868960916996002, 0.30220004916191101, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[2*10] = { 
  0.52238994836807251, -0.56808286905288696, 0.40211349725723267, 0.59624427556991577, 0.68358319997787476, -0.44468295574188232, -0.24818657338619232, -0.61767363548278809, 0.048608284443616867, 0.47288241982460022, 
  0.27399149537086487, 0.079585075378417969, -0.12610673904418945, -0.12876875698566437, -0.53105461597442627, -0.0014603137969970703, -0.6530379056930542, 0.32925030589103699, -0.52059686183929443, 0.22275003790855408, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 2,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,2 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,2 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension0, 84, },
  { kTfLiteMmapRo, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 40, },
  { kTfLiteMmapRo, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 80, },
  { kTfLiteMmapRo, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 8, },
  { kTfLiteMmapRo, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 1680, },
  { kTfLiteMmapRo, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 800, },
  { kTfLiteMmapRo, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 80, },
  { kTfLiteArenaRw, tensor_arena + 96, (TfLiteIntArray*)&tensor_dimension7, 80, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension8, 40, },
  { kTfLiteArenaRw, tensor_arena + 48, (TfLiteIntArray*)&tensor_dimension9, 8, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension10, 8, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_SOFTMAX, },
};

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  if (current_location - bytes < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  };
  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }
  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }

  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }
  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }
  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }
};

} // namespace

TfLiteStatus tflite_learn_17_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  ctx.impl_ = static_cast<void*>(&micro_context_);
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t i = 0; i < 4; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
tflNodes[i].custom_initial_data = nullptr;
      tflNodes[i].custom_initial_data_size = 0;
if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for (size_t i = 0; i < 4; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      ResetTensors();

      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteStatus tflite_learn_17_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(inTensorIndices[index], tensor);
  return kTfLiteOk;
}

static const int outTensorIndices[] = {
  10, 
};
TfLiteStatus tflite_learn_17_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(outTensorIndices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_17_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_17_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
